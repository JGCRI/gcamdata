% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeline-helpers.R
\name{protect_integer_cols}
\alias{protect_integer_cols}
\alias{unprotect_integer_cols}
\title{Protect column names that are bare integers from being interpreted as integers}
\usage{
protect_integer_cols(d)

unprotect_integer_cols(d)
}
\arguments{
\item{d}{The data to have integer column names protected or unprotected}
}
\value{
Tibble with the integer column names protected
}
\description{
\code{protect_integer_cols} will prepend an 'X' to column names that are bare
integers to protect them from being misinterpreted during sensitive
operations (see below).  \code{unprotect_integer_cols} will reverse the
effect, reverting the column names to their original form.
}
\details{
Some of our data frames have column names that are years, such as "2005".  In
some cases a column name of this form can be misinterpreted as a column
index, the (likely nonexistent) 2005th column in this example.  The *_if
functions in dplyr are examples of such circumstances.  Protecting the column
names with a leading character allows these functions to perform normally.

Much of the data system is expecting years in column names to be bare
integers; therefore, you should unprotect the column names as soon as the
sensitive operations are complete.
}
\examples{
library(magrittr)
df <- dplyr::tibble(iso=c('bad','dum'), `2005`=c(123.45, NA), `2050`=c(867, 5309))
protect_integer_cols(df) \%>\%
    dplyr::select_if(function(col) {!any(is.na(col))}) \%>\%
    unprotect_integer_cols
}
